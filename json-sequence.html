<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>JavaScript Object Notation (JSON) Text Sequences</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "December 2014"; 
  } 
  @top-center {
       content: "JSON Text Sequences"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Expires June 21, 2015"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction and Motivation" href="#rfc.section.1"><link rel="Chapter" title="2 JSON Text Sequence Format" href="#rfc.section.2"><link rel="Chapter" title="3 Security Considerations" href="#rfc.section.3"><link rel="Chapter" title="4 IANA Considerations" href="#rfc.section.4"><link rel="Chapter" title="5 Acknowledgements" href="#rfc.section.5"><link rel="Chapter" href="#rfc.section.6" title="6 Normative References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.580, 2012-06-03 11:18:18, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Williams, N."><meta name="dct.identifier" content="urn:ietf:id:draft-ietf-json-text-sequence-12"><meta name="dct.issued" scheme="ISO8601" content="2014-12-18"><meta name="dct.abstract" content="This document describes the JSON text sequence format and associated media type, &#8220;application/json-seq&#8221;. A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8, each prefixed by an ASCII Record Separator (0x1E), and each ending with an ASCII Line Feed character (0x1A)."><meta name="description" content="This document describes the JSON text sequence format and associated media type, &#8220;application/json-seq&#8221;. A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8, each prefixed by an ASCII Record Separator (0x1E), and each ending with an ASCII Line Feed character (0x1A)."></head><body><table class="header"><tbody><tr><td class="left">
json
</td><td class="right">N. Williams</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Cryptonector</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">December 18, 2014</td></tr><tr><td class="left">Expires: June 21, 2015</td><td class="right"></td></tr></tbody></table><p class="title">JavaScript Object Notation (JSON) Text Sequences<br><span class="filename">draft-ietf-json-text-sequence-12</span></p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>This document describes the JSON text sequence format and associated media type, &#8220;application/json-seq&#8221;. A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8, each prefixed by an ASCII Record Separator (0x1E), and each ending with an ASCII Line Feed character (0x1A).</p><h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#8220;work in progress&#8221;.</p><p>This Internet-Draft will expire on June 21, 2015.</p><h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1><p>Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li>1.&nbsp;&nbsp;&nbsp;<a href="#d1e215">Introduction and Motivation</a><ul><li>1.1&nbsp;&nbsp;&nbsp;<a href="#d1e236">Conventions used in this document</a></li></ul></li><li>2.&nbsp;&nbsp;&nbsp;<a href="#sec_JSON_Text_Sequence">JSON Text Sequence Format</a><ul><li>2.1&nbsp;&nbsp;&nbsp;<a href="#sub_ParsingRules">JSON text sequence parsing</a></li><li>2.2&nbsp;&nbsp;&nbsp;<a href="#sub_EncodingRules">JSON text sequence encoding</a></li><li>2.3&nbsp;&nbsp;&nbsp;<a href="#d1e385">Incomplete/invalid JSON texts need not be fatal</a></li><li>2.4&nbsp;&nbsp;&nbsp;<a href="#sub_Top_level">Top-level numeric, 'true', 'false', and 'null' values</a></li></ul></li><li>3.&nbsp;&nbsp;&nbsp;<a href="#sec_Security_Considerations">Security Considerations</a></li><li>4.&nbsp;&nbsp;&nbsp;<a href="#sec_IANA_Considerations">IANA Considerations</a></li><li>5.&nbsp;&nbsp;&nbsp;<a href="#d1e602">Acknowledgements</a></li><li>6.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul><ul class="toc"><li>Figures
        <ul><li><a href="#rfc.figure.1">Figure 1: JSON text sequence ABNF</a></li><li><a href="#rfc.figure.2">Figure 2: JSON text sequence ABNF</a></li></ul></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="d1e215" href="#d1e215">Introduction and Motivation</a></h1><p id="rfc.section.1.p.1">The JavaScript Object Notation (JSON) <a href="#RFC7159"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC7159]</cite></a> is a very handy serialization format. However, when serializing a large sequence of values as an array, or a possibly indeterminate-length or never-ending sequence of values, JSON becomes difficult to work with.</p><p id="rfc.section.1.p.2">Consider a sequence of one million values, each possibly 1 kilobyte when encoded -- roughly one gigabyte. It is often desirable to process such a dataset in an incremental manner: without having to first read all of it before beginning to produce results. Traditionally the way to do this with JSON is to use a &#8220;streaming&#8221; parser, but these are neither widely available, widely used, nor easy to use.</p><p id="rfc.section.1.p.3">This document describes the concept and format of &#8220;JSON text sequences&#8221;, which are specifically not JSON texts themselves but are composed of (possible) JSON texts. JSON text sequences can be parsed (and produced) incrementally without having to have a streaming parser (nor streaming encoder).</p><h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="d1e236" href="#d1e236">Conventions used in this document</a></h2><p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", &#8220;NOT RECOMMENDED&#8221;, "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="sec_JSON_Text_Sequence" href="#sec_JSON_Text_Sequence">JSON Text Sequence Format</a></h1><p id="rfc.section.2.p.1">Two different sets of ABNF rules are provided for the definition of JSON text sequences: one for parsers, and one for encoders. Having two different sets of rules permits recovery by parsers from sequences where some the elements are truncated for whatever reason. The syntax for parsers is specified in terms of octet strings which are then interpreted as JSON texts if possible. The syntax for encoders, on the other hand, assumes that sequence elements are not truncated.</p><p id="rfc.section.2.p.2">JSON text sequences MUST use UTF-8 encoding; other encodings of JSON (i.e., UTF-16 and UTF-32) MUST NOT be used.</p><h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="sub_ParsingRules" href="#sub_ParsingRules">JSON text sequence parsing</a></h2><p id="rfc.section.2.1.p.1">The ABNF <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> for the JSON text sequence parser is as given in <a href="#fig_ABNF_parser">Figure&nbsp;1</a>.</p><p id="rfc.section.2.1.p.3"> </p><div id="fig_ABNF_parser"></div><div id="rfc.figure.1"></div><pre>  JSON-sequence = *(1*RS possible-JSON)
  RS = %x1E; "record separator" (RS), see RFC20
           ; Also known as: Unicode Character 'INFORMATION SEPARATOR
           ;                TWO' (U+001E)
  possible-JSON = 1*(not-RS); attempt to parse as UTF-8-encoded
                            ; JSON text (see RFC7159)
  not-RS = %x00-1d / %x1f-ff; any octets other than RS</pre><p class="figure">Figure 1: JSON text sequence ABNF</p><p id="rfc.section.2.1.p.4">In prose: a series of octet strings, each containing any octet other than a record separator (RS) (0x1E) [RFC0020], all octet strings separated from each other by RS octets. Each octet string in the sequence is to be parsed as a JSON text in the UTF-8 encoding [RFC3629].</p><p id="rfc.section.2.1.p.5">If parsing of such an octet string as a UTF-8-encoded JSON text fails, the parser SHOULD nonetheless continue parsing the remainder of the sequence. The parser can report such failures to applications (which might then choose to terminate parsing of a sequence). Multiple consecutive RS octets do not denote empty sequence elements between them, and can be ignored.</p><p id="rfc.section.2.1.p.6">This document does not define a mechanism for reliably identifying text sequence by position (for example, when sending individual elements of an array as unique text sequences). For applications where truncation is a possibility, this means that intended sequence elements can be truncated, and can even be missing entirely, therefore a reference to an nth element would be unreliable.</p><p id="rfc.section.2.1.p.7">There is no end of sequence indicator.</p><h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="sub_EncodingRules" href="#sub_EncodingRules">JSON text sequence encoding</a></h2><p id="rfc.section.2.2.p.1">The ABNF for the JSON text sequence encoder is given in <a href="#fig_ABNF_encoder">Figure&nbsp;2</a>.</p><p id="rfc.section.2.2.p.3"> </p><div id="fig_ABNF_encoder"></div><div id="rfc.figure.2"></div><pre>  JSON-sequence = *(RS JSON-text LF)
  RS = %x1E; see RFC20
           ; Also known as: Unicode Character 'INFORMATION SEPARATOR
           ;                TWO' (U+001E)
  LF = %x0A; "line feed" (LF), see RFC20
  JSON-text = &lt;given by RFC7159, using UTF-8 encoding&gt;</pre><p class="figure">Figure 2: JSON text sequence ABNF</p><p id="rfc.section.2.2.p.4">In prose: any number of JSON texts, each encoded in UTF-8 <a href="#RFC3629"><cite title="UTF-8, a transformation format of ISO 10646">[RFC3629]</cite></a>, each preceded by one ASCII RS character, and each followed by a line feed (LF). Since RS is an ASCII control character it may only appear in JSON strings in escaped form (see <a href="#RFC7159"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC7159]</cite></a>), and since RS may not appear in JSON texts in any other form, RS unambiguously delimits the start of any element in the sequence. RS is sufficient to unambiguously delimit all top-level JSON value types other than numbers. Following each JSON text in the sequence with an LF allows detection of truncated JSON texts consisting of a number at the top-level; see <a href="#sub_Top_level" title="Top-level numeric, 'true', 'false', and 'null' values">Section&nbsp;2.4</a>.</p><p id="rfc.section.2.2.p.5">JSON text sequence encoders are expected to ensure that the sequence elements are properly formed. When the JSON text sequence encoder does the JSON text encoding, the sequence elements will naturally be properly formed. When the JSON text sequence encoder accepts already-encoded JSON texts, the JSON text sequence encoder ought to to parse them before adding them to a sequence.</p><p id="rfc.section.2.2.p.6">Note that on some systems it's possible to input RS by typing 'ctrl-^'; on some system or applications the correct sequence may be 'ctrl-v crtl-^'. This is helpful when constructing a sequence manually with a text editor.</p><h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="d1e385" href="#d1e385">Incomplete/invalid JSON texts need not be fatal</a></h2><p id="rfc.section.2.3.p.1">Per- <a href="#sub_ParsingRules" title="JSON text sequence parsing">Section&nbsp;2.1</a>, JSON text sequence parsers should not abort when an octet string contains a malformed JSON text, instead the JSON text sequence parser should skip to the next RS. Such a situation may arise in contexts where, for example, append-writes to log files are truncated by the filesystem (e.g., due to a crash, or administrative process termination).</p><p id="rfc.section.2.3.p.2">Incremental JSON text parsers may be used, though of course failure to parse a given text may result after first producing some incremental parse results.</p><p id="rfc.section.2.3.p.3">Sequence parsers should have an option to warn about truncated JSON texts.</p><h2 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a id="sub_Top_level" href="#sub_Top_level">Top-level numeric, 'true', 'false', and 'null' values</a></h2><p id="rfc.section.2.4.p.1">While objects, arrays, and strings are self-delimited in JSON texts, numbers, and the values 'true', 'false', and 'null' are not. Only whitespace can delimit the latter four kinds of values.</p><p id="rfc.section.2.4.p.2">JSON text sequences use 0x0A as a "canary" octet to detect truncation.</p><p id="rfc.section.2.4.p.3">Parsers MUST check that any JSON texts that are a top-level number, or which might be 'true', 'false', or 'null' include JSON whitespace (at least one byte matching the &#8220;ws&#8221; ABNF rule from <a href="#RFC7159"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC7159]</cite></a>) after that value, otherwise the JSON-text may have been truncated. Note that the LF following each JSON text matches the &#8220;ws&#8221; ABNF rule.</p><p id="rfc.section.2.4.p.4">Parsers MUST drop JSON-text sequence elements consisting of non-self-delimited top-level values that may have been truncated (that are not delimited by whitespace). Parsers can report such texts as warnings (including, optionally, the parsed text and/or the original octet string).</p><p id="rfc.section.2.4.p.5">For example, '&lt;RS&gt;123&lt;RS&gt;' might have been intended to carry the top-level number 1234, but must have been truncated. Similarly, '&lt;RS&gt;true&lt;RS&gt;' might have been intended to carry the invalid text 'trueish'. '&lt;RS&gt;truefalse&lt;RS&gt;' is not two top-level values, 'true', and 'false'; it is simply not a valid JSON text.</p><p id="rfc.section.2.4.p.6">Implementations may produce a value when parsing '&lt;RS&gt;&#8221;foo&#8221;&lt;RS&gt;' because their JSON text parser might be able to consume bytes incrementally, and since the JSON text in this case is a self-delimiting top-level value, the parser can produce the result without consuming an additional byte. Such implementations ought to skip to the next RS byte, possibly reporting any intervening non-whitespace bytes.</p><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="sec_Security_Considerations" href="#sec_Security_Considerations">Security Considerations</a></h1><p id="rfc.section.3.p.1">All the security considerations of JSON <a href="#RFC7159"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC7159]</cite></a> apply. This format provides no cryptographic integrity protection of any kind.</p><p id="rfc.section.3.p.2">As usual, parsers must operate on as-good-as untrusted input. This means that parsers must fail gracefully in the face of malicious inputs.</p><p id="rfc.section.3.p.3">Note that incremental JSON text parsers can produce partial results and later indicate failure to parse the remainder of a text. A sequence parser that uses an incremental JSON text parser might treat a sequence like '&lt;RS&gt;&#8221;foo&#8221;&lt;LF&gt;456&lt;LF&gt;&lt;RS&gt;' as a sequence of one element (&#8220;foo&#8221;), while a sequence parser that uses a non-incremental JSON text parser might treat the same sequence as being empty. This effect, and texts that fail to parse and are ignored can be used to smuggle data past sequence parsers that don't warn about JSON text failures.</p><p id="rfc.section.3.p.4">Repeated parsing and re-encoding of a JSON text sequence can result in the addition (or stripping) of trailing LF bytes from (to) individual sequence element JSON texts. This can break signature validation. JSON has no canonical form for JSON texts, therefore neither does the JSON text sequence format.</p><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="sec_IANA_Considerations" href="#sec_IANA_Considerations">IANA Considerations</a></h1><p id="rfc.section.4.p.1">The MIME media type for JSON text sequences is application/json-seq.</p><p id="rfc.section.4.p.2">Type name: application</p><p id="rfc.section.4.p.3">Subtype name: json-seq</p><p id="rfc.section.4.p.4">Required parameters: N/A</p><p id="rfc.section.4.p.5">Optional parameters: N/A</p><p id="rfc.section.4.p.6">Encoding considerations: binary</p><p id="rfc.section.4.p.7">Security considerations: See &lt;this document, once published&gt;, <a href="#sec_Security_Considerations" title="Security Considerations">Section&nbsp;3</a>.</p><p id="rfc.section.4.p.8">Interoperability considerations: Described herein.</p><p id="rfc.section.4.p.9">Published specification: &lt;this document, once published&gt;.</p><p id="rfc.section.4.p.10">Applications that use this media type: &lt;by publication time &lt;<a href="https://stedolan.github.io/jq">https://stedolan.github.io/jq</a>&gt; is likely to support this format&gt;.</p><p id="rfc.section.4.p.11">Fragment identifier considerations: N/A.</p><p id="rfc.section.4.p.12">Additional information:</p><p id="rfc.section.4.p.13"> </p><ul><li>Deprecated alias names for this type: N/A.</li><li>Magic number(s): N/A</li><li>File extension(s): N/A.</li><li>Macintosh file type code(s): N/A.</li><li>Person &amp; email address to contact for further information: <ul><li>json@ietf.org</li></ul> </li><li>Intended usage: COMMON</li><li>Author: See the "Authors' Addresses" section of this document.</li><li>Change controller: IETF</li></ul><hr class="noprint"><h1 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a id="d1e602" href="#d1e602">Acknowledgements</a></h1><p id="rfc.section.5.p.1">Phillip Hallam-Baker proposed the use of JSON text sequences for logfiles and pointed out the need for resynchronization. Stephen Dolan created &lt;<a href="https://github.com/stedolan/jq">https://github.com/stedolan/jq</a>&gt;, which uses something like JSON text sequences (with LF as the separator between texts on output, and requiring only such whitespace as needed to disambiguate on input). Carsten Bormann suggested the use of ASCII RS, and Joe Hildebrand suggested the use of LF in addition to RS for disambiguating top-level number values. Paul Hoffman shepherded the Internet-Draft. Many others contributed reviews and comments on the JSON Working Group mailing list.</p><h1 class="np" id="rfc.references"><a href="#rfc.section.6" id="rfc.section.6">6.</a> Normative References</h1><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC0020">[RFC0020]</b></td><td class="top">Cerf, V., &#8220;<a href="http://tools.ietf.org/html/rfc20">ASCII format for network interchange</a>&#8221;, RFC&nbsp;20, October&nbsp;1969.</td></tr><tr><td class="reference"><b id="RFC3629">[RFC3629]</b></td><td class="top">Yergeau, F., &#8220;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>&#8221;, STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003.</td></tr><tr><td class="reference"><b id="RFC5234">[RFC5234]</b></td><td class="top">Crocker, D. and P. Overell, &#8220;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>&#8221;, STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008.</td></tr><tr><td class="reference"><b id="RFC7159">[RFC7159]</b></td><td class="top">Bray, T., &#8220;<a href="http://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>&#8221;, RFC&nbsp;7159, March&nbsp;2014.</td></tr></table><hr class="noprint"><div class="avoidbreak"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address></div></body></html>